---
title: MSSQL 트랜잭션과 잠금
author: Koreandns
date: 2020-07-26 14:00:00 +0800
categories: [MSSQL, transaction]
tags: [MSSQL, transaction]
---



트랜잭션에 대해서 알아보자.



![](C:\git\koreandns.github.io\img\tran.png)





트랜잭션이란 논리적인 작업의 처리 단위를 말한다. 트랜잭션이 필요한 이유를 그림을 보면서 알아보자.

국민은행에서 신한은행으로 돈을 보내려고 한다면 당연히 국민은행에서는 돈이 출금이 일어나야하고, 신한은행으로 입금이 되어야 한다. 만약 국민은행에서 돈이 출금이 일어나고 시스템 장애가 와서 신한은행으로 입금이 안 일어난다면 당연히 관련된 다른 처리도 모두 취소 되어야 한다.

이러한 기능이 트랜잭션이다. 즉 모두 성공하거나 아무것도 일어나지 않아야 한다.



----



트랜잭션 로그에 대해서 알아보자



트랜잭션과 관련된 로그는 트랜잭션 로그 파일에 기록되는데 이러한 로그 파일로 나중에 복구를 하게 되거나 데이터 베이스 유지할때 중요하므로 데이터 파일과 다른 저장 디스크에 별도로 저장하는게 바람직하다.



![](C:\git\koreandns.github.io\img\tranLog.png)





① 트랜잭션이 발생하고 트랜잭션이 끝나고 체크 포인트가 발생하였다. 이미 실제  데이터 파일로 옮겨졌기 때문에 아무 일도 발생하지 않는다.

② 트랜잭션이 발생하고 중간에 체크 포인트가 발생하였다. 일 부분만 실제 데이터 파일로 옮겨졌고 그 다음 트랜잭션이 완료되고 시스템 장애가 발생하였다. 자동 복구 프로세스에 의해서 복구 될 때 로그에 기록된 내용을 바탕으로 실제 데이터로 반영해주는 롤 포워드 발생

③ 트랜잭션이 발생하고 일 부분만 체크 포인트에 의해서 시스템이 반영되었다. 하지만 트랜잭션이 완료되기 전에 시스템 장애가 발생하였다. 다시 시스템이 재 시작 되면 롤백으로 인해서 모두 되 돌린다.

④ 트랜잭션이 일어나고 완료되었다. 하지만 체크포인트는 일어나지 않아서 실제 데이터 파일로 반영되진 않았다. 그 다음 시스템 장애가 발생하고 시스템이 재 시작되었다면 로그를 참조하여 실제 데이터로 반영해주는 롤 포워드가 일어난다.

⑤ 트랜잭션이 발생하고 완료되기 전에 시스템 장애가 발생한다면 아무 작업도 해 줄 필요가 없다.



----



잠금에 대해서 알아보고 난 뒤 Intent Lock에 대해서 좀 더 구체적으로 알아볼 것이다.



잠금은 동일한 시간에 동일한 데이터를 동시에 액세스 할 수 있도록 해주는 메커니즘이다. 잠금은 트랜잭션을 순차적으로 처리하도록 하므로 데이터에 대한 일관성과 동시 사용이 가능합니다. 또한 자동으로 발생합니다.



| 잠금 유형 | 설명                                                      |
| --------- | --------------------------------------------------------- |
| 읽기 잠금 | 다른 사용자와 읽는것은 허용하지만 쓰는 것은 허용하지 않음 |
| 쓰기 잠금 | 다른 사용자와 읽는것도 쓰는것도 허용하지 않음             |



지금부터 잠금 모드에 대해서 간략하게 살펴보고 Intent Lock에 대해서 드디어 알아볼때가 왔습니다.

1. 공유 잠금 (S) :  어떤 데이터를 읽기 위해서 접근할때 공유 잠금을 건다. 다른 트랜잭션에서도 동일한 데이터에 접근해서 읽으려고 하면 공유 잠금을 걸 수 있다. 만약 여러행을 읽는다고 가정한다면 다음 행을 읽을때 현재 행은 공유 잠금이 해제 된다. 이러한 공유 잠금은 쿼리의 조건이 만족하는 모든 행이 클라이언트로 전달될 때까지 유지된다.

2. 단독 잠금 (X) : insert, update, delete문을 수행하기 위해서 다른 트랜잭션은 접근을 못하도록 단독 잠금을 건다. 하지만 hint 또는 트랜잭션 격리수준을 사용해서 다른 트랜잭션에서 읽는거 까지는 허용해준다.

3. 의도된 잠금 (IS, IX, SIX) : SQL Server는 잠금을 걸 수 있을지 없을지를 신속히 확인하기 위해서 사용한다.



나는 이 의도된 잠금이 뭔지 정말로 궁금했다.. 어떤 용도로 만들어진 잠금이고 이게 왜 필요한지..

그래서 구글링을 열심히 해 보았다..



![](C:\git\koreandns.github.io\img\intent_lock1.png)

​                                                                                                              잠금 계층 구조는 이렇게 되어 있다.





![](C:\git\koreandns.github.io\img\intent_lock2.png)

1. 한 행에 대해서 공유 잠금을 걸었다.
2. 다수의 사용자가 여러 행에 대해서 수정을 하려고 한다. 이럴때 어디가 문제일까?
3. 페이지에 락을 걸고 싶겠지만 이미 하위 계층 한 행에 대해서 공유 잠금이 있다. 하지만 SQL Server는 공유 잠금이 있는지 여부를 알 수가 없다. 그래서 모든 단일 행을 돌면서 잠금 여부를 확인을 해야 한다. 이 시간 비용과 자원이 상당히 클것이다.



그러면 이러한 문제점이 있는 것을 알았으니 이제 어떻게 이러한 문제점을 보완할 수 있을까? 그래서 나온게 Intent Lock 이다.



![](C:\git\koreandns.github.io\img\intent_lock3.png)

Intent Lock 적용이 되었으니 다시 살펴보자.

1. 한 사용자가 한 행에 대해서 공유 잠금을 걸자마자 상위 페이지와 테이블에게도 의도된 잠금(Intent Lock)이 걸린다.
2. 다수의 사용자가 이제 여러 행에 대해서 수정하려고 페이지에 락을 걸려고 시도하지만 이미 페이지와 테이블쪽에 잠금이 있다는 것을 알고 잠금을 걸 수 없다는 사실을 바로 알아버린다. 이러면 모든 단일 행을 돌면서 잠금이 있는지 여부를 확인하지 않아도 되기 때문에 시간 비용과 자원을 아낄 수 있다.



Intent Lock은 이러한 목적이다.





참조

https://docs.microsoft.com/ko-kr/sql/relational-databases/system-stored-procedures/sp-lock-transact-sql?view=sql-server-ver15

https://www.sqlservercentral.com/blogs/intent-locks-in-sql-server

https://ko.wikipedia.org/wiki/ACID

